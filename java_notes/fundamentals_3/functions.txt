### Functions - Reusable blocks of code ###

Another essential concept in coding is functions, which allow you to store a piece
of code that does a single task inside a defined block, and then call that code
whenever you need it using a single short command - rather than having to type out
the same code multiple times.

## Where do I find functions? ###

In JavaScript, you'll find functions everywhere. Now it's time to start really
exploring the syntax of functions.

Pretty much anytime you make use of a JavaScript structure that features a pair of
brackets - () - and you're not using a common built-in language structure like a
for loop, while or do...while loop or if...else statement, you are using a functinon.

## Built-in browser functions ##

We've used functions built in to the browser a lot in this course.

Every time we manupulated a text string ,for example:

const myText = "I am a string";
const newString = myText.replace("string", "sausage");
console.log(newString);
// the replace() string function takes a source string,
// and a target string and replaces the source string,
// with the target string, and returns the newly formed string

We were using a function!

## Function Scope & Conflicts ##

Scope is a very important concept when dealing with functions.
When you create a function, the variables and other things inside the
function are inside their own separate scope, meaning that they are
locked away in their own separate compartments, unreachable from
code outside the functions.

The top level outside all your functions is called the global scope.
Values defined in the global scope are accessible from everywhere
in the code.

JavaScript is set up like this for various reasons.
But mainly because of security and organisation.
Sometimes you don't want variables to be accesible from everywhere
in the code. External scripts that you call in from elswhere could
start to mess with your code and cause problems because they happen
to be using the same variable names as other parts of the code,
causing conflics. This might be done maliciously, or just by accident.

For example, say you have a HTML file that is calling in two external
JavaScript files, and both of themhave a variable and a function defined
that use the same name:

<!-- Excerpt from my HTML -->
<script src="first.js"></script>
<script src="second.js"></script>
<script>
  greeting();
</script>

// first.js
const name = "Chris";
function greeting() {
  alert(`Hello ${name}: welcome to our company.`);
}

// second.js
const name = "Zaptec";
function greeting() {
  alert(`Our company is called ${name}.`);
}

Both functions you want to call are called greeting(),
but you can only ever access the first.js file's greeting() function
whilst the second one is ignored. In addition, an error results when
attempting (in the second.js file) to assign a new value to the name
variable, because it was already declared with const, and so cannot
be reassigned.

Keeping parts of your code locked away in functions avoids such problems,
and is considered best practice.

It is a bit like a zoo. The lions, zebras,tigers and penguins are
kept in their own enclosures, and only have access to the things inside
their enclosures, in the same manner as the function scopes.
If they were able to get into other enclosures, problems would occur.
At best, different animals would feel really uncomfortable inside
unfamiliar habitats. A Lion or tiger would feel terrible inside the
penguins' watery, icy domain. At worst, the lions and tigers might try
to eat the penguins.

The Zoo Keeper is like the global scope, they have the keys to access
every enclosure, to restock foot, tend to sick animals, etc.

## Playing with Scope ##

Let's look at an example to demonstrate scoping.

First, make a local copy of our function-scope.html example.
This contains two functions called a() and b(), and three variables
— x, y, and z — two of which are defined inside the functions,
and one in the global scope. It also contains a third function
called output(), which takes a single parameter and outputs it
in a paragraph on the page.
Open the example up in a browser and in your text editor.
Open the JavaScript console in your browser developer tools.
In the JavaScript console, enter the following command:

output(x);

You should see the value of variable x printed to the browser viewport.
Now try entering the following in your console

output(y);
output(z);

Both of these should throw an error into the console along the lines
of "ReferenceError: y is not defined". Why is that? Because of
function scope — y and z are locked inside the a() and b() functions,
so output() can't access them when called from the global scope.
However, what about when it's called from inside another function?
Try editing a() and b() so they look like this:

function a() {
  const y = 2;
  output(y);
}

function b() {
  const z = 3;
  output(z);
}

Save the code and reload it in your browser, then try calling the
a() and b() functions from the JavaScript console:

a();
b();

You should see the y and z values printed in the browser viewport.
This works fine, as the output() function is being called inside
the other functions — in the same scope as the variables it is
printing are defined in, in each case. output() itself is available
from anywhere, as it is defined in the global scope.
Now try updating your code like this:

function a() {
  const y = 2;
  output(x);
}

function b() {
  const z = 3;
  output(x);
}

Save and reload again, and try this again in your JavaScript console:

a();
b();

Both the a() and b() call should print the value of x to the browser
viewport. These work fine because even though the output()
calls are not in the same scope as x is defined in, x is a
global variable so is available inside all code, everywhere.
Finally, try updating your code like this:

function a() {
  const y = 2;
  output(z);
}

function b() {
  const z = 3;
  output(y);
}

Save and reload again, and try this again in your JavaScript console:

a();
b();

This time the a() and b() calls will throw that annoying ReferenceError:
 variable name is not defined error into the console
 — this is because the output() calls and the variables
 they are trying to print are not in the same function scopes
 — the variables are effectively invisible to those function calls.


 