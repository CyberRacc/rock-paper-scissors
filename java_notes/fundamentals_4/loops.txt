
## Looping Code ##

    Programming languages are very useful for rapidly completing repetitive tasks, from multiple
    basic calculations to just about any other situation where you've got a lot of similar
    items of work to complete. Here we'll look at the loop structures available in
    JavaScript that handle such needs.

    ## Why are loops useful? ##

    Loops are all about doing the same thing over and over again. Often, the code will be
    slightly different each time round the loop, or the same code will run but with
    different variables.

## Looping through a collection ##

    Most of the time when you use a loop, you will have a collection of items and want to do
    something with every item.

    One type of collection is the Array. But there are other collections in JavaScript as well,
    including Set and Map.

## The for...of loop ##

    The basic tool for looping through a collection is the for...of loop:

    const cats = ["Leapard", "Serval", "Jaguar", "Tiger", "Caracal", "Lion"];

    for (const cat of cats) {
        console.log(cat);
    }

    In this example, for (const cat of cats) says:

        1. Given the collection of cats, get the first item in the collection.

        2. Assign it to the variable cat and then run the code between the curly brackets {}.

        3. Get the next item, and repeat (2) until you've reached the end of the collection.

## map() and filter() ##

    JavaScript also has more specialised loops for collections, and we'll mention two of
    them here.

    You can use map() to do something to each item in a collection and create a new
    collection containing the changed items:

        function toUpper(string) {
            return string.toUpperCase();
        }

        const cats = ["Leopard", "Serval", "Jaguar", "Tiger", "Caracal", "Lion"];

        const upperCats = cats.map(toUpper);

        console.log(upperCats);
        // [ "LEOPARD", "SERVAL", "JAGUAR", "TIGER", "CARACAL", "LION" ]

    
    Here we pass a function into cats.map(), and map() calls the function once for each item
    in the array, passing in the item. It then adds the return value from each function call
    to a new array, and finally returns the new array. In this case the fucntion we provide
    converts the item to uppercase, so the resulting arary contains all our cats in uppercase.

    You can use filter() to test each item in a collection, and create a new collection
    containing only items that match:

        function lCat(cat) {
            return cat.startsWith("l");
        }

        const cats = ["Leopard", "Serval", "Jaguar", "Tiger", "Caracal", "Lion"];

        const filtered = cats.filter(lcat);

        console.log(filtered);
        // ["Leadpard", "Lion"]

    This looks a lot like a map(), except the function we pass in returns a
    boolean: if it returns true then the item is included in the new array.
    Our function tests that the item strats with the letter "L", so the
    result is in an array containing only cats whose names start with "L":

    [ "Leapard", "Lion" ]

    Note that map() and filter() are both often used with function
    expressions. Using function expressions we could rewrite the
    example above to be much more compact:

    const cats = ["Leopard", "Serval", "Jaguar",
    "Tiger", "Caracal", "Lion"];

    const filtered = cats.filter((cat) =>
    cat.startsWith("L"));
    console.log(filtered);
    // ["Leapard", "Lion"]

## The standard for loop ##

    In the "drawing circles" example, you don't have a collection of items
    to loop through: you really just want to run the same code 100 times.
    In a case like that, you should use the for loop. This has the following
    syntax:

    for (initialiser; condition; final-expression) {
        // code to run
    }

    Here we have:

        1. The keyword for, followed by brackets.

        2. Inside the brackets we have three items, separated by semi-colons:

            i. An initialiser - this is usually a variable set to a number,
            which is incremented to count to the number of times the loop
            has run. It is also sometimes referred to as a counter
            variable.

            ii. A condition - this defines when the loop should stop looping.
            This is generally an expression featuring a comparison operator,
            a test to see if the exit condition has been met.

        3. Some curly brackets that contain a block of code -
        this code will be run each time the loop iterates.

## Calculating Squares ##

    Let's look at a real example so we can visualise these do
    more clearly.

    const results =
    document.querySelector("#results");

    function calculate() {
        for (let i = 1; i < 10; i++) {
            const newResult = `${1} x ${1} =${1 * 1}`;
            results.textContent += `${newResult}\n`;
        }
        results.textContent += "\nFinished!"
    }

    const calculateBtn =
    document.querySelector("#calculate");
    const clearBtn =
    document.querySelector("#clear");

    calculateBtn.addEventListener("click",
    calculate);
    clearBtn.addEventListener("click", () =>
    (results.textContent = ""));

    This gives us this output:

        1 x 1 = 1
        2 x 2 = 4
        3 x 3 = 9
        4 x 4 = 16
        5 x 5 = 25
        6 x 6 = 36
        7 x 7 = 49
        8 x 8 = 64
        9 x 9 = 81

        Finished!

    This code calculates squares for the numbers from 1 to 9,
    and writes out the result. The core of the code is the for
    loop that performs the calculation.

    Let's break down the for (let i =1; i < 10; i++) line into its
    three pieces:

        1. let i = 1: the counter variables, i, starts at 1. Note
        that we have to use let for the counter because we're reassigning it
        each time we go round the loop.

        2. i < 10: keep going round the loop for as long as i is smaller
        than 10.

        3. i++: add one to 1 each time round the loop.

    Inside the loop
