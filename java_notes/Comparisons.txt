
## Comparisons in js ##

Greater/less than: a > b, a < b.

Greater/Less than or equals: a >= b, a <= b.

Equals: a == b, please note the double equality sign ==, it means the equality test,
whilst a single one a = b means an assignment.

Not equals: a != b

All comparisons result in a boolean.

booleans:
true
false

examples:
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)

A comparison result can be assigned to a variable, just like any value:
let result = 5 > 4; // assign the result of the comparison
alert( result ); // true

## String Comparison ##

To see if a string is greater than another, JavaScript uses the so-called
"dictionary" or "lexicographical" order.

Meaning strings are compared letter-by-letter.

Example:
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true

The algorithm to compare to strings is simple:

1. Compare the first character of both strings.
2. If the first character from the first string is greater (or less) than the other
string's, then the first string is greater (or less) than the second. We're done.
3. Otherwise, if both strings' first characters are the same, compare the
second characters the same way.
4. Repease until the end of either string.
5. If both strings end a the same length, then they are equal. Otherwise, the longer
string is greater.

In the first example above, the comparison 'Z' > 'A' gets to a result at the first step.

The second comparison 'Glow' and 'Glee' needs more steps as strings are compared
character-by-character.

1. G is the same as G.
2. 1 is the same as 1.
3. o is greater than e. Stop here. The first string is greater.

# Note # 

Not a real dictionary, but Unicode order

The comparison algorithm given above is roughly equivalent to the one used in
dictionaries or phone books, but it’s not exactly the same.

For instance, case matters. A capital letter "A" is not equal to the lowercase "a".
Which one is greater? The lowercase "a". Why? Because the lowercase character has a greater
 index in the internal encoding table JavaScript uses (Unicode).
We’ll get back to specific details and consequences of this in the chapter Strings.

## Comparisons of different types ##

When comparing values of different types, JavaScript converts the values to numbers.

For example:
alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1

For boolean values, true becomes 1 and falso becomes 0.

For example:
alert( true == 1 ); // true
alert( false == 0 ); // true

# A funny consequence #

It's possible that at the same time:

 - Two values are equal.
 - One of them is true as a boolean and one of them is false as a boolean.

 For example:
 let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!

From JavaScript’s standpoint, this result is quite normal.
An equality check converts values using the numeric
conversion (hence "0" becomes 0), while the explicit Boolean
conversion uses another set of rules.

## Strict equality ##

A regular equality check == has a problem. It cannot differentiate 0 from false:

alert( 0 == false ); // true

The same thing happens with an empty string:

alert( '' == false ); // true

This happens because operands of different types are converted to numbers by
the equality operator ==. An empty string, just like false, becomes a zero.

What to do if we'd like to differentiate 0 from false?

A strict equality operator === checks the equality without type conversion.

In other words, if a and b are of different types, then a === b immediately
returns false without an attempt to convert them.

Let's try it:

alert( 0 === false ); // false, because the types are different

There is also a "strict non-equality" operator !== analogous to !=.

The strict equality operator is a bit longer to write, but makes it obvious
what's going on and leaves less room for errors.

## Comparison with null and undefined ##

There's a non-intuitive behaviour when null or undefined are compared to other values.

For a strict equality check ===

These values are different, because each of them is a different type.

alert( null === undefined ); // false

For a non-strict check ==

There's a special rule. These two are a "sweet couple": they equal each other
(in the sense of ==), but not any other value.

alert( null == undefined ); // true

In practice, null and undefined are often used interchangeably to represent the absence of a value.
However, there are some conventions that JavaScript developers often follow:

undefined typically means that a variable has been declared,
but has not been assigned a value.
null is typically used to represent "no value" or "no object".
It needs to be assigned explicitly, indicating that the variable should have no value.

For maths and other comparisons < > <= >=

null/undefined are converted to numbers: null becomes 0, whilst undefined becomes NaN.

Now let's see some funny things that happen when we apply these rules.
And, what's more important, how to not fall into a trap with them.

## Strange result: null vs 0 ##

Let's compare null with a zero:

alert( null > 0 ); // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

    alert( null >= 0 ); // true

This is where it gets weird. You'd think that, because (null > 0) is false,
(null >= 0) should also be false.
But in JavaScript, x >= y is not exactly the same as !(x < y).

The >= operator actually does two comparisons: x > y or x == y. So in this case,
null >= 0 is checking if null is greater than 0 (it's not) or null is equal to 0.

While null == 0 is false, in the context of the >= operator,
JavaScript converts null to a number before making the comparison,
so it actually ends up comparing 0 >= 0, which is true.

This is one of the quirkiest parts of JavaScript.
It's a result of the way the language's type coercion and comparison rules are defined.
In general, to avoid confusion, it's often recommended to use 
strict equality (=== and !==) and strict comparison operators whenever possible,
as they don't perform type coercion.

## Summary ##

-    Comparison operators return a boolean value.
-    Strings are compared letter-by-letter in the “dictionary” order.
-    When values of different types are compared,
     they get converted to numbers (with the exclusion of a strict equality check).
-    The values null and undefined equal == each other and do not equal
     any other value.
-    Be careful when using comparisons like > or < with variables
     that can occasionally be null/undefined.
     Checking for null/undefined separately is a good idea.

What will be the result for these expressions?

5 > 4 → true
"apple" > "pineapple" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false

Detailed reasoning: 

This one is straightforward. 5 is indeed greater than 4.

    "apple" > "pineapple" → false

Strings are compared character by character in lexicographical
(dictionary) order. The first characters of both strings are compared first.
If the first characters are equal, then the second characters are compared,
and so on. In this case, "apple" comes before "pineapple" in dictionary order,
so "apple" > "pineapple" is false.

    "2" > "12" → true

When strings containing numerical characters are compared,
they are still compared lexicographically, not numerically.
In lexicographic order, "2" comes after "1", so "2" > "12" is true.

    undefined == null → true

As we discussed before, null and undefined are equal to each
other (and nothing else) when using the loose equality ==.

    undefined === null → false

With strict equality ===, null and undefined are not the same.
They are different types, so undefined === null is false.

    null == "\n0\n" → false

Here, "\n0\n" is a string that contains a number.
In a loose equality comparison with null, JavaScript does not perform
type coercion to convert the string to a number, so null is not equal to "\n0\n".

    null === +"\n0\n" → false

The unary + operator tries to convert its operand to a number.
So +"\n0\n" is equivalent to 0. However, with the strict equality operator ===,
null and 0 are not the same because they are of different types.

